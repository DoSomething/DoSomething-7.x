<?php

/**
 * @file
 * Custom functionality to change roles of users depending on their activity.
 */

/**
 * Implements hook_cron().
 */
function dosomething_roles_cron() {
  // Update users roles who have not been assigned to the new roles.
  // Note: this can be removed once all users have roles.
  $inactive_user = user_role_load_by_name('inactive user');
  $member = user_role_load_by_name('member');
  $active_member = user_role_load_by_name('active member');
  $rids = $inactive_user->rid . ', ' . $member->rid . ', ' . $active_member->rid;
  $result = db_query_range("SELECT u.uid, u.access FROM {users} u LEFT JOIN {users_roles} ur ON (ur.uid = u.uid AND ur.rid IN ($rids)) WHERE ur.uid IS NULL AND u.uid > 0 ORDER BY u.access ASC", 0, 100);
  foreach ($result as $data) {
    dosomething_roles_update_role($data->uid);
  }

  // Get users who have not logged in this past year for possible role regression.
  // TODO: Get users who have not done any action updates in 1 year, 9 months, 10 months, 11 months
  // After 1 year, we bump them down
  // We warn them at the other points.
  $last_update_inactive = variable_get('dosomething_roles_cron_inactive', 0);
  $result = db_query_range("SELECT u.uid, u.access FROM {users} u INNER JOIN {users_roles} ur ON (u.uid = ur.uid AND ur.rid IN (:active_member, :member)) WHERE access < UNIX_TIMESTAMP(DATE_SUB(CURRENT_TIMESTAMP(),interval 1 year)) AND access > :last_update_inactive ORDER BY u.access ASC", 0, 100, array(':active_member' => $active_member->rid, ':member' => $member->rid, ':last_update_inactive' => $last_update_inactive));
  foreach ($result as $data) {
     dosomething_roles_update_role($data->uid);
     variable_set('dosomething_roles_cron_inactive', $data->access); 
  }
}

/**
 *
 *  TODO: Enable this in cron, clean up these comments, extensive testing.
 *  Move this
  // For each result
      // if it is the current timestamp and uid is less than the current uid, then move along
      // If it is a staff member, then skip but set timestamp and uid values.
      // load profile and account
      // check on future member status
      // if it is different, and it is lower, then we send an email. 
      // set uid and timestamp variables

// Look people up whose anniversary is x months away.
  // Keep track of x month day (and uid)

  // One the first of the month, start grabbing everyone who will expire in x months during the month.
  // Start emailing them one by one and keep track of the uid.

  // On the first of the next month if our list has anyone left, then we're in trouble because we're
  // not sending them out fast enough.

  // You'll have to figure out what the user's status will be in x months too.


 */
function dosomething_roles_send_demotion_notifications($month) {
  $current_timestamp = strtotime("+$month month", REQUEST_TIME);
  $current_month = date('m', $current_timestamp);
  $current_year = date('Y', $current_timestamp);
  $beginning_timestamp = strtotime("$current_month/01/$current_year");
  $checking_month = variable_get('dosomething_roles_member_demotion_notice_' . $month . '_month', 01);
  $role_hierarchy = dosomething_roles_get_membership_role_hierarchy();

  // It's a new month, so let's start over.
  if ($current_month != $checking_month) {
    variable_set('dosomething_roles_member_demotion_notice_' . $month . '_timestamp', $beginning_timestamp);
    variable_set('dosomething_roles_member_demotion_notice_' . $month . '_uid', 0);
    variable_get('dosomething_roles_member_demotion_notice_' . $month . '_month', $current_month);
  }
  $last_checked_timestamp = variable_get('dosomething_roles_member_demotion_notice_' . $month . '_timestamp', $beginning_timestamp);
  $current_uid = variable_get('dosomething_roles_member_demotion_notice_' . $month . '_uid', 0);
  $end_timestamp = strtotime("+1 month", $beginning_timestamp);
  $results = dosomething_roles_get_users_by_anniversary($last_checked_timestamp, $end_timestamp);

  if (isset($results['profile2']) && count($results['profile2'])) {
    foreach ($results['profile2'] as $profile_data) {
      $profile = profile2_load($profile_data->pid);
      $account = user_load($profile->uid);
      $anniversary = dosomething_roles_get_anniversary($account->uid);
      if (($account->uid >= $current_uid) && ($anniversary == $last_checked_timestamp)) {
        continue;
      }
      else if (dosomething_roles_user_is_staff_member($account->uid)) {
        variable_set('dosomething_roles_member_demotion_notice_' . $month . '_uid', $account->uid);
        variable_set('dosomething_roles_member_demotion_notice_' . $month . '_timestamp', $anniversary);
        continue;
      }

      $current_role_name = 'inactive user';
      $new_role_name = dosomething_roles_get_member_role($account->uid, strtotime("+1 day", $anniversary));
      $new_role_weight = array_search($new_role_name, $role_hierarchy);
      $intersection = array_intersect($role_hierarchy, $account->roles);
      if (is_array($intersection)) {
        // Note: only one of these roles should be in the roles list.
        // If there are more, then the highest level (lowest weight) is grabbed.
        $current_role_name = array_shift($intersection);
      }
      $current_role_weight = array_search($current_role_name, $role_hierarchy);

      if ($current_role_weight > $new_role_weight) {
        // TODO: Send them a stern warning.
      }
      variable_set('dosomething_roles_member_demotion_notice_' . $month . '_uid', $account->uid);
      variable_set('dosomething_roles_member_demotion_notice_' . $month . '_timestamp', $anniversary);
    }
  }
}

/**
 * Implements hook_mail().
 */
function dosomething_roles_mail($key, &$message, $params) {
  switch ($key) {
    case 'dosomething-roles-old-person-email':
      $params['full_name'] = dosomething_login_get_user_full_name($params['account']);
      $message['subject'] = t('You\'re membership has expired.');
      $message['body'][] = drupal_html_to_text(theme('dosomething_roles_old_person_email', $params));
      $message['headers']['Content-Type'] = 'text/html; charset=utf-8';
      break;
  }
}

/**
 * Implements hook_theme().
 */
function dosomething_roles_theme() {
  return array(
    'dosomething_roles_old_person_email' => array(
      'path' => drupal_get_path('module', 'dosomething_roles') . '/templates',
      'arguments' => array('full_name' => NULL),
      'template' => 'dosomething-roles-old-person-email',
    ),
  );
}

/**
 * Update a user's membership role.
 */
function dosomething_roles_update_role($uid) {
  if (!$uid || $uid == 1) {
    return;
  }
  global $language;
  $account = user_load($uid);

  if (dosomething_roles_user_is_staff_member($account)) {
    return;
  }

  // TODO: It would be nice to do the hierarchy with the role weights.
  $rids = array();
  $roles = user_roles();
  $current_role_name = 'inactive user';
  $role_hierarchy = dosomething_roles_get_membership_role_hierarchy();
  $intersection = array_intersect($role_hierarchy, $account->roles);
  $rids = array_flip($role_hierarchy);
  if (is_array($intersection)) {
    // Note: only one of these roles should be in the roles list.
    // If there are more, then the highest level (lowest weight) is grabbed.
    $current_role_name = array_shift($intersection);
  }

  $new_role_name = dosomething_roles_get_member_role($uid);
  $anniversary = dosomething_roles_get_anniversary($uid);
  $new_role_weight = array_search($new_role_name, $role_hierarchy);
  $current_role_weight = array_search($current_role_name, $role_hierarchy);
  $new_anniversary = strtotime('+1 year');

  // If the role has increased, increase the role, and set new anniversary
  if ($new_role_weight < $current_role_weight) {
    dosomething_roles_set_anniversary($uid, $new_anniversary);
    $new_rid = $rids[$new_role_name];
  }
  // Else if it's past the anniversary set a new one.
  else if (REQUEST_TIME >= $anniversary) {
    dosomething_roles_set_anniversary($uid, $new_anniversary);
    if ($new_role_weight > $current_role_weight) {
      // If the role level has decreased, then downgrade.
      $role_name = $role_hierarchy[$new_role_weight];
      $new_rid = $rids[$role_name];
    }
  }

  // If a user turns 26, then they are immediately set to 'old person'.
  if ($new_role_name == 'old person' && $new_role_name != $current_role_name) {
    // Note: It may be better to user_save here.  If we decide to, then we need
    //  to add a flag to the account object (no_dosomething_role_update) to
    //  prevent an infinite loop.
    global $language;
    $new_rid = $rids[$new_role_name];
    db_update('users')->fields(array('status' => 0))->condition('uid', $account->uid)->execute();
    $params = array('account' => $account);
    drupal_mail('dosomething_roles', 'dosomething-roles-old-person-email', $account->mail, $language, $params);
  }

  if (isset($new_rid)) {
    db_delete('users_roles')->condition('rid', $rids, 'IN')->condition('uid', $uid, '=')->execute();
    db_insert('users_roles')->fields(array('uid' => $uid, 'rid' => $new_rid ))->execute();
  }
}

/**
 * Get a list of node types that are considered 'action updates'.
 */
function dosomething_roles_get_action_update_types() {
  return array(
    'campaign_report_back',
    'campaign_sign_up',
    'grant_application',
    'scholarship_application',
    'action_guide',
    'project_report',
  );
}

/**
 * Get a list of the mebership roles in order from highest level
 *  to lowest level.  Lower weight = Higher level.
 */
function dosomething_roles_get_membership_role_hierarchy() {
  return  array(
    'varsity',
    'active member',
    'member',
    'inactive user',
    'old person',
  );
}

/**
 * Determine if athe given user is a staff member.
 */
function dosomething_roles_user_is_staff_member($account) {
  if (is_numeric($account)) {
    $account = user_load($account);
  }
  // TODO: Maybe we should have another role to mark
  // non-staff users so we can check for that?
  $staff_roles = array(
    'administrator',
    'content loader',
    'developer',
    'grant reviewer',
    'grant alumni',
    'help desk',
    'moderator',
    'project_police',
  );
  if (count(array_intersect($staff_roles, $account->roles))) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_node_insert().
 */
function dosomething_roles_node_insert($node) {
  global $user;
  if ($user->uid == $node->uid) {
    if ($node->type == 'final_grant_update') {
      dosomething_roles_update_role($node->uid);
    }
  }
}

/**
 * Implements hook_user_login().
 */
function dosomething_roles_user_login(&$edit, $account) {
  // Don't run this on the first login.
  if ($account->access) {
    dosomething_roles_update_role($account->uid);
  }
}

/**
 * Implements hook_user_update().
 */
function dosomething_roles_user_update(&$edit, $account, $category) {
  global $user;
  // To prevent infinite loop, add no_dosomething_role_update if running
  // user_save while updating a role.
  if ($user->uid == $account->uid && !isset($account->no_dosomething_role_update)) {
    dosomething_roles_update_role($account->uid);
  }
}

/**
 * Implements hook_webform_submission_insert().
 */
function dosomething_roles_webform_submission_insert($node, $submission) {
  global $user;
  if ($user->uid == $submission->uid) {
    if (in_array($node->type, dosomething_roles_get_action_update_types())) {
      dosomething_roles_update_role($submission->uid);
    }
  }
}

/**
 * Implements hook_webform_submission_update().
 */
function dosomething_roles_webform_submission_update($node, $submission) {
  if (in_array($node->type, dosomething_roles_get_action_update_types())) {
    if (dosomething_roles_user_is_staff_member($submission->uid)) {
      return;
    }
    if ($submission->is_draft) {
      $timestamp = strtotime('-1 year');
      $role_name = dosomething_roles_get_member_role($submission->uid);
      if ($role_name == 'member') {
        // Role user back to being a member immediately,
        //  because their action update is now unpublished.
        $rids = array();
        $roles = user_roles();
        $role_hierarchy = dosomething_roles_get_membership_role_hierarchy();
        foreach ($role_hierarchy as $weight => $role_name) {
          $rids[$role_name] = array_search($role_name, $roles);
        }
        db_delete('users_roles')->condition('rid', $rids, 'IN')->condition('uid', $uid, '=')->execute();
        db_insert('users_roles')->fields(array('uid' => $uid, 'rid' => $rids['member']))->execute();
      }
    }
    else {
      dosomething_roles_update_role($submission->uid);
    }
  }
}

/**
 * Determine a user's role level without considering their 'Aniversary Date'
 *  when the role to actually change.
 *
 *  Rules:
 *  old person - user over 25.
 *  inactive user - under 26, hasn't logged in during the last year.
 *  member - continue to be under 26.
 *  active member - one action update within year.
 *    They also must provide their school name and zipcode,
 *      but that's conatined in the action update.
 *    If their action update is unpublished, then they should
 *      immediately fall to 'member'. (See hook_webform_submission_update).
 *  varsity - 5 action updates or win grant and submit grant update.
 *
 * @param $uid
 *  (int) uid from account object.
 * @param $end_timestamp
 *  (int) timestamp of date from which to determine membership level. (OPTIONAL)
 *   By default this will determine level at the current time.
 * @return string
 */
function dosomething_roles_get_member_role($uid, $end_timestamp = NULL) {
  $account = user_load($uid);
  $end_timestamp = is_null($end_timestamp) ? REQUEST_TIME : $end_timestamp;
  $timestamp = strtotime('-1 year', $end_timestamp);
  $action_update_count = dosomething_roles_get_action_update_count($uid, $timestamp);
  $grant_update = dosomething_roles_user_submitted_grant($uid, $timestamp);

  if (module_exists('dosomething_login')) {
    if (dosomething_login_drupal_user_is_over_age($uid, 25, $end_timestamp)) {
      return 'old person';
    }
  }
  if ($action_update_count >= 5 || $grant_update) {
    $role_name = 'varsity';
  }
  else if ($action_update_count >= 1) {
    $role_name = 'active member';
  }
  else if ($account->login >= $timestamp) {
    $role_name = 'member';
  }
  else {
    $role_name = 'inactive member';
  }
  return $role_name;
}

/**
 * Get a user's current membership role.
 */
function dosomething_roles_get_current_role($uid) {
  $current_role_name = 'inactive user';
  $account = user_load($uid);
  $role_hierarchy = dosomething_roles_get_membership_role_hierarchy();
  $intersection = array_intersect($role_hierarchy, $account->roles);
  if (is_array($intersection)) {
    // Note: only one of these roles should be in the roles list.
    // If there are more, then the highest level (lowest weight) is grabbed.
    $current_role_name = array_shift($intersection);
  }
  return $current_role_name;
}

/**
 * This will get the number of action updates since the given time.
 *
 * @param $uid
 * @param $timestamp
 * @return mixed
 *  Returns int or NULL if unsuccessful.
 */
function dosomething_roles_get_action_update_count($uid, $timestamp, $draft = FALSE) {
  // TODO: If the status is 'Idea' it doesn't count.
  // What is this status?
  $node_types = dosomething_roles_get_action_update_types();
  try {
    $query = db_select('webform_submissions', 'w');
    $query->innerJoin('node', 'n', 'w.nid = n.nid');
    $count = $query->fields('w', array('sid'))
    ->condition('w.uid', $uid, '=')
    ->condition('n.type', $node_types, 'IN')
    ->condition('w.is_draft', (int) $draft)
    ->condition('w.submitted', $timestamp, '>')
    ->execute()
    ->rowCount();
  }
  catch (Exception $e) {
    $count = NULL;
  }
  return $count;
}

/**
 * Determine if a user has submitted a grant update within
 *  the given span of time.
 */
function dosomething_roles_user_submitted_grant($uid, $timestamp) {
  // TODO: Verify that this is the grant update.
  $query = new EntityFieldQuery;
  try {
    $count = $query
      ->entityCondition('entity_type', 'node')
      ->propertyCondition('uid', $uid)
      ->propertyCondition('type', 'final_grant_update')
      ->propertyCondition('status', NODE_PUBLISHED)
      ->propertyCondition('created', $timestamp, '>')
      ->count()
      ->execute();
  }
  catch (Exception $e) {
    return NULL;
  }
  return $count;
}

/**
 * Get the anniversary of this user's member level.
 *  When a user increases their role, they get it for one year.
 */
function dosomething_roles_get_anniversary($uid) {
  $account = user_load($uid);
  $profile = profile2_load_by_user($account, 'main');
  if (is_object($profile)) {
    $date = field_get_items('profile2', $profile, 'field_user_anniversary');
    if (isset($date[0]['value'])) {
      return $date[0]['value'];
    }
  }
  return REQUEST_TIME;
}

/**
 * Set a new membership anniversary for a user.
 */
function dosomething_roles_set_anniversary($uid, $timestamp) {
  $account = user_load($uid);
  $profile = profile2_load_by_user($account, 'main');
  // Create a profile if it doesn't exist.
  if (!$profile) {
    $values = array(
      'type' => 'main',
      'user' => $account,
    );
    $create_function = function_exists('profile2_create') ? 'profile_create' : 'profile_create';
    $profile = profile_create($values);
    profile2_save($profile);
  }

  $profile->field_user_anniversary[LANGUAGE_NONE][0]['value'] = $timestamp;
  field_attach_update('profile2', $profile);
}

/**
 * Determine how close a user is from moving to the next level.
 */
function dosomething_roles_get_user_percentage($uid) {
  $account = user_load($uid);
  $current_role = dosomething_roles_get_current_role($uid);
  $timestamp = strtotime('-1 year');
  $percent = 0;
  switch ($current_role) {
    case 'varsity':
      $percent = 100;
      break;
    case 'active member':
      $count = dosomething_roles_get_action_update_count($uid, $timestamp);
      $percent = $count > 5 ? 100 : 20 * $count;
      break;
    case 'member':
      $percent = 50 * dosomething_roles_profile_ratio($uid);
      if (dosomething_roles_get_action_update_count($uid, $timestamp);
        $percent += 50;
      }
      else if (dosomething_roles_get_action_update_count($uid, $timestamp, TRUE);
        // TODO: This 'intent' to do an action has not been implemented yet.
        $percent += 25;
      }
      break;
  }
  return $percent;
}

/**
 * Figure out how much of a user's profile has
 *  been committed.
 */
function dosomething_roles_profile_ratio($uid) {
  $account = user_load($uid);
  $profile = profile2_load_by_user($account, 'main');
  $total = 0;
  $complete = 0;

  if (is_object($profile)) {
    foreach ($profile as $field_name => $values) {
      if (substr($field_name, 0, 5) == 'field') {
        $total++;
        if (count($values)) {
          $complete++;
        }
      }
    }
  }
  if ($total) {
    return $complete / $total;
  }
  return 0;
}

/**
 * Implements hook_form_profile2_edit_TYPE_form_alter().
 */
function dosomething_roles_form_profile2_edit_main_form_alter(&$form, &$form_state) {
  // Disable access to anniversary field.  This could be done with
  // field permissions, but until we need more fine grained permissions
  // on other fields, let's not add more overhead to this site.
  if (isset($form['profile_main']['field_user_anniversary'])) {
    unset($form['profile_main']['field_user_anniversary']);
  }
}

/**
 * TODO: Comment this stuff.
 */
function dosomething_roles_get_users_by_anniversary($start_date, $end_date = NULL, $limit = 10) {
  if (is_null($end_date)) {
    $end_date = REQUEST_TIME;
  }
  $query = new EntityFieldQuery;
  try {
    $results = $query
      ->entityCondition('entity_type', 'profile2')
      ->propertyCondition('type', 'main', '=')
      ->fieldCondition('field_user_anniversary', 'value', array($start_date, $end_date), 'BETWEEN')
      ->fieldOrderBy('field_user_anniversary', 'value')
      ->propertyOrderBy('uid')
      ->range(0, $limit)
      ->execute();
    return $results;
  }
  catch (Exception $e) {
    return NULL;
  }
  return $count;
}

