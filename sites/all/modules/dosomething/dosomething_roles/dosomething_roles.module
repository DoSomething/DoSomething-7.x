<?php

/**
 * @file
 * Custom functionality to change roles of users depending on their activity.
 */

/**
 * Implements hook_cron().
 */
function dosomething_roles_cron() {
  // Send notifications for users about to lose membership status.
  for ($month = 3; $month > 0; $month--) {
    dosomething_roles_send_demotion_notifications($i);
  }

  // Get users whose anniversaries have past and demote them, if necessary.
  dosomething_roles_demote_expired_users();
}

/**
 * Update roles for users whose anniversaries have passed.
 * Note: this should only do 10 at a time based on 
 * dosomething_roles_get_users_by_anniversary.
 */
function dosomething_roles_demote_expired_users() {
  $last_checked_timestamp = variable_get('dosomething_roles_member_demotion_last_timestamp', 0);
  $last_uid = variable_get('dosomething_roles_member_demotion_last_uid', 0);
  $results = dosomething_roles_get_users_by_anniversary($last_checked_timestamp, REQUEST_TIME);
  if (isset($results['profile2']) && count($results['profile2'])) {
    foreach ($results['profile2'] as $profile_data) {
      $profile = profile2_load($profile_data->pid);
      $account = user_load($profile->uid);
      $anniversary = dosomething_roles_get_anniversary($account->uid);
      if (!dosomething_roles_user_is_staff_member($account->uid)) {
        if ($account->uid > $last_uid || $last_checked_timestamp < $anniversary) {
          // Find what a user's role will be after updating.
          $new_role_name = dosomething_roles_get_member_role($account->uid);
          $current_role_name = dosomething_roles_get_current_role($account->uid);

          dosomething_roles_update_role($account->uid);

          if ($new_role_name != $current_role_name) {
            global $language;
            $params = array(
              'new_role' => $new_role_name,
            );
            drupal_mail('dosomething_roles', 'dosomething-roles-demotion', $account->mail, $language, $params);
          }
        }
      }
      variable_set('dosomething_roles_member_demotion_last_timestamp', $anniversary);
      variable_set('dosomething_roles_member_demotion_last_uid', $account->uid);
      $last_checked_timestamp = $anniversary;
    }
  }
}

/**
 *  Lookup people whose anniversary is x months away.  This will run through
 *   anyone's membership whose anniversary takes place in the month that
 *   is x months away.  On the first of the month, it will move on to the
 *   next month, so the previous month should be finisehd by that point.
 *
 * @param $month
 *  (int) number of months away.
 */
function dosomething_roles_send_demotion_notifications($month) {
  $current_timestamp = strtotime("+$month month", REQUEST_TIME);
  $current_month = date('n', $current_timestamp);
  $current_year = date('Y', $current_timestamp);
  $beginning_timestamp = strtotime("$current_month/01/$current_year");
  $checking_month = variable_get('dosomething_roles_member_demotion_notice_' . $month . '_month', 1);
  $role_hierarchy = dosomething_roles_get_membership_role_hierarchy();

  // It's a new month, so let's start over.
  if ($current_month != $checking_month) {
    variable_set('dosomething_roles_member_demotion_notice_' . $month . '_timestamp', $beginning_timestamp);
    variable_set('dosomething_roles_member_demotion_notice_' . $month . '_uid', 0);
    variable_set('dosomething_roles_member_demotion_notice_' . $month . '_month', $current_month);
  }
  $last_checked_timestamp = variable_get('dosomething_roles_member_demotion_notice_' . $month . '_timestamp', $beginning_timestamp);
  $current_uid = variable_get('dosomething_roles_member_demotion_notice_' . $month . '_uid', 0);
  $end_timestamp = strtotime("+1 month", $beginning_timestamp);
  $results = dosomething_roles_get_users_by_anniversary($last_checked_timestamp, $end_timestamp);

  if (isset($results['profile2']) && count($results['profile2'])) {
    foreach ($results['profile2'] as $profile_data) {
      $profile = profile2_load($profile_data->pid);
      $account = user_load($profile->uid);
      $anniversary = dosomething_roles_get_anniversary($account->uid);

      // Don't send the email to the same person twice.
      if (($account->uid <= $current_uid) && ($anniversary == $last_checked_timestamp)) {
        continue;
      }
      // Don't mess with the roles of staff members.
      else if (dosomething_roles_user_is_staff_member($account->uid)) {
        variable_set('dosomething_roles_member_demotion_notice_' . $month . '_uid', $account->uid);
        variable_set('dosomething_roles_member_demotion_notice_' . $month . '_timestamp', $anniversary);
        continue;
      }

      // Find what a user's role will be when they're anniversary has passed.
      $new_role_name = dosomething_roles_get_member_role($account->uid, $end_timestamp);
      $new_role_weight = array_search($new_role_name, $role_hierarchy);
      $current_role_name = dosomething_roles_get_current_role($account->uid);
      $current_role_weight = array_search($current_role_name, $role_hierarchy);

      if ($current_role_weight < $new_role_weight) {
        global $language;
        $params = array(
          'months' => $month,
          'new_role' => $new_role_name,
          'current_role' => $current_role_name,
        );
        drupal_mail('dosomething_roles', 'dosomething-roles-impending-demotion', $account->mail, $language, $params);
      }
      // Mark this user as done by setting the last uid and last anniversary checked.
      variable_set('dosomething_roles_member_demotion_notice_' . $month . '_uid', $account->uid);
      variable_set('dosomething_roles_member_demotion_notice_' . $month . '_timestamp', $anniversary);
    }
  }
}

/**
 * Implements hook_mail().
 */
function dosomething_roles_mail($key, &$message, $params) {
  switch ($key) {
    case 'dosomething-roles-old-person-email':
      $params['full_name'] = module_exists('dosomething_login') ? dosomething_login_get_user_full_name($params['account']) : $params['account']->name;
      $message['subject'] = t('You\'re membership has expired.');
      $message['body'][] = drupal_html_to_text(theme('dosomething_roles_old_person_email', $params));
      $message['headers']['Content-Type'] = 'text/html; charset=utf-8';
      break;
    case 'dosomething-roles-demotion':
      $message['subject'] = t('Membership demotion.');
      $message['body'][] = drupal_html_to_text(theme('dosomething_roles_demotion_email', $params));
      $message['headers']['Content-Type'] = 'text/html; charset=utf-8';
      break;
    case 'dosomething-roles-impending-demotion':
      $message['subject'] = t('Impending membership demotion.');
      $message['body'][] = drupal_html_to_text(theme('dosomething_roles_impending_demotion_email', $params));
      $message['headers']['Content-Type'] = 'text/html; charset=utf-8';
      break;
  }
}

/**
 * Implements hook_theme().
 */
function dosomething_roles_theme() {
  return array(
    'dosomething_roles_old_person_email' => array(
      'path' => drupal_get_path('module', 'dosomething_roles') . '/templates',
      'arguments' => array('full_name' => NULL),
      'template' => 'dosomething-roles-old-person-email',
    ),
    'dosomething_roles_demotion_email' => array(
      'path' => drupal_get_path('module', 'dosomething_roles') . '/templates',
      'arguments' => array(
        'current_role' => NULL,
        'new_role' => NULL,
        'months' => NULL,
      ),
      'template' => 'dosomething-roles-demotion-email',
    ),
    'dosomething_roles_impending_demotion_email' => array(
      'path' => drupal_get_path('module', 'dosomething_roles') . '/templates',
      'arguments' => array(
        'current_role' => NULL,
        'new_role' => NULL,
        'months' => NULL,
      ),
      'template' => 'dosomething-roles-impending-demotion-email',
    ),
  );
}

/**
 * Update a user's membership role.
 */
function dosomething_roles_update_role($uid) {
  if (!$uid || $uid == 1) {
    return;
  }
  global $language;
  $account = user_load($uid);

  // Don't make the user a full member if they are currently pendig.
  if (in_array('pending member', $account->roles)) {
    return;
  }

  if (dosomething_roles_user_is_staff_member($account)) {
    return;
  }

  // TODO: It would be nice to do the hierarchy with the role weights.
  $rids = array();
  $roles = user_roles();
  $role_hierarchy = dosomething_roles_get_membership_role_hierarchy();
  $intersection = array_intersect($role_hierarchy, $account->roles);
  $rids = array_flip(array_intersect($roles, $role_hierarchy));
  $current_role_name = dosomething_roles_get_current_role($account->uid);

  $new_role_name = dosomething_roles_get_member_role($uid);
  $anniversary = dosomething_roles_get_anniversary($uid);
  $new_role_weight = array_search($new_role_name, $role_hierarchy);
  $current_role_weight = array_search($current_role_name, $role_hierarchy);
  $new_anniversary = strtotime('+1 year');

  // If the role has increased, increase the role, and set new anniversary
  if ($new_role_weight < $current_role_weight) {
    dosomething_roles_set_anniversary($uid, $new_anniversary);
    $new_rid = $rids[$new_role_name];
  }
  // Else if it's past the anniversary set a new one.
  else if (REQUEST_TIME >= $anniversary) {
    dosomething_roles_set_anniversary($uid, $new_anniversary);
    if ($new_role_weight > $current_role_weight) {
      // If the role level has decreased, then downgrade.
      $role_name = $role_hierarchy[$new_role_weight];
      $new_rid = $rids[$role_name];
    }
  }

  // If a user turns 26, then they are immediately set to 'old person'.
  if ($new_role_name == 'old person' && $new_role_name != $current_role_name) {
    // Note: It may be better to user_save here.  If we decide to, then we need
    //  to add a flag to the account object (no_dosomething_role_update) to
    //  prevent an infinite loop.
    global $language;
    $new_rid = $rids[$new_role_name];
    db_update('users')->fields(array('status' => 0))->condition('uid', $account->uid)->execute();
    $params = array('account' => $account);
    drupal_mail('dosomething_roles', 'dosomething-roles-old-person-email', $account->mail, $language, $params);
  }

  if (isset($new_rid)) {
    db_delete('users_roles')->condition('rid', $rids, 'IN')->condition('uid', $uid, '=')->execute();
    db_insert('users_roles')->fields(array('uid' => $uid, 'rid' => $new_rid ))->execute();

    //$account = user_load($uid, TRUE);
  }
}

/**
 * Get a list of node types that are considered 'action updates'.
 */
function dosomething_roles_get_action_update_types() {
  return array(
    'campaign_report_back',
    'campaign_sign_up',
    'grant_application',
    'scholarship_application',
    'action_guide',
    'project_report',
  );
}

/**
 * Get a list of the mebership roles in order from highest level
 *  to lowest level.  Lower weight = Higher level.
 */
function dosomething_roles_get_membership_role_hierarchy() {
  return  array(
    'varsity',
    'active member',
    'member',
    'inactive user',
    'old person',
  );
}

/**
 * Determine if athe given user is a staff member.
 */
function dosomething_roles_user_is_staff_member($account) {
  if (is_numeric($account)) {
    $account = user_load($account);
  }
  // TODO: Maybe we should have another role to mark
  // non-staff users so we can check for that?
  $staff_roles = array(
    'administrator',
    'content loader',
    'developer',
    'grant reviewer',
    'grant alumni',
    'help desk',
    'moderator',
    'project_police',
  );
  if (count(array_intersect($staff_roles, $account->roles))) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_node_insert().
 */
function dosomething_roles_node_insert($node) {
  global $user;
  if ($user->uid == $node->uid) {
    if ($node->type == 'final_grant_update') {
      dosomething_roles_update_role($node->uid);
    }
  }
}

/**
 * Implements hook_user_login()r
 */
function dosomething_roles_user_login(&$edit, $account) {
  // Don't run this on the first login.
  if ($account->access) {
    dosomething_roles_update_role($account->uid);
  }
}

/**
 * Implements hook_user_update().
 */
function dosomething_roles_user_update(&$edit, $account, $category) {
  global $user;
  // To prevent infinite loop, add no_dosomething_role_update if running
  // user_save while updating a role.
  if ($user->uid == $account->uid && !isset($account->no_dosomething_role_update)) {
    dosomething_roles_update_role($account->uid);
  }
}

/**
 * Implements hook_entity_update().
 */
function dosomething_roles_entity_update($entity, $type) {
  if ($type == 'profile2') {
    dosomething_roles_update_role($entity->uid);
  }
}

/**
 * Implements hook_webform_submission_insert().
 */
function dosomething_roles_webform_submission_insert($node, $submission) {
  global $user;
  if ($user->uid == $submission->uid) {
    if (in_array($node->type, dosomething_roles_get_action_update_types())) {
      dosomething_roles_update_role($submission->uid);
    }
  }
}

/**
 * Implements hook_webform_submission_update().
 */
function dosomething_roles_webform_submission_update($node, $submission) {
  if (in_array($node->type, dosomething_roles_get_action_update_types())) {
    if (dosomething_roles_user_is_staff_member($submission->uid)) {
      return;
    }
    // If a submission is a draft, then make sure any previous credit
    // for this webform is taken away.
    if ($submission->is_draft) {
      $timestamp = strtotime('-1 year');
      $new_role_name = dosomething_roles_get_member_role($submission->uid);
      $current_role_name = dosomething_roles_get_current_role($submission->uid);
      if ($new_role_name == 'member' && $current_role_name == 'active member') {
        // Role user back to being a member immediately,
        //  because their action update is now unpublished.
        $rids = array();
        $roles = user_roles();
        $role_hierarchy = dosomething_roles_get_membership_role_hierarchy();
        foreach ($role_hierarchy as $weight => $role_name) {
          $rids[$role_name] = array_search($new_role_name, $roles);
        }
        db_delete('users_roles')->condition('rid', $rids, 'IN')->condition('uid', $uid, '=')->execute();
        db_insert('users_roles')->fields(array('uid' => $uid, 'rid' => $rids['member']))->execute();
      }
    }
    else {
      dosomething_roles_update_role($submission->uid);
    }
  }
}

/**
 * Determine a user's role level without considering their 'Aniversary Date'
 *  when the role to actually change.
 *
 *  Rules:
 *  old person - user over 25.
 *  inactive user - under 26, hasn't logged in during the last year.
 *  member - continue to be under 26.
 *  active member - one action update within year.
 *    They also must provide their school name and zipcode,
 *      but that's conatined in the action update.
 *    If their action update is unpublished, then they should
 *      immediately fall to 'member'. (See hook_webform_submission_update).
 *  varsity - 5 action updates or win grant and submit grant update.
 *
 * @param $uid
 *  (int) uid from account object.
 * @param $end_timestamp
 *  (int) timestamp of date from which to determine membership level. (OPTIONAL)
 *   By default this will determine level at the current time.
 * @return string
 */
function dosomething_roles_get_member_role($uid, $end_timestamp = NULL) {
  $account = user_load($uid);
  $end_timestamp = is_null($end_timestamp) ? REQUEST_TIME : $end_timestamp;
  $timestamp = strtotime('-1 year', $end_timestamp);
  $action_update_count = dosomething_roles_get_action_update_count($uid, $timestamp);
  $grant_update = dosomething_roles_user_submitted_grant($uid, $timestamp);
  $ratio = dosomething_roles_profile_ratio($uid);

  if (module_exists('dosomething_login')) {
    if (dosomething_login_drupal_user_is_over_age($uid, 26, $end_timestamp)) {
      return 'old person';
    }
  }
  if ($action_update_count >= 5 || $grant_update && $ratio >= 1) {
    $role_name = 'varsity';
  }
  else if ($action_update_count >= 1 && $ratio >= 1) {
    $role_name = 'active member';
  }
  else if ($account->login >= $timestamp) {
    $role_name = 'member';
  }
  else {
    $role_name = 'inactive user';
  }
  return $role_name;
}

/**
 * Get a user's current membership role.
 */
function dosomething_roles_get_current_role($uid) {
  $current_role_name = 'inactive user';
  $account = user_load($uid);
  $role_hierarchy = dosomething_roles_get_membership_role_hierarchy();
  $intersection = array_intersect($role_hierarchy, $account->roles);
  if (!empty($intersection)) {
    // Note: only one of these roles should be in the roles list.
    // If there are more, then the highest level (lowest weight) is grabbed.
    $current_role_name = array_shift($intersection);
  }
  return $current_role_name;
}

/**
 * This will get the number of action updates since the given time.
 *
 * @param $uid
 * @param $timestamp
 * @return mixed
 *  Returns int or NULL if unsuccessful.
 */
function dosomething_roles_get_action_update_count($uid, $timestamp, $draft = FALSE) {
  // If the status of a submission is 'Idea', it doesn't count.
  // That status is only relevant for project_reports.
  $node_types = dosomething_roles_get_action_update_types();
  try {
    $query = db_select('webform_submissions', 'w');
    $query->innerJoin('node', 'n', 'w.nid = n.nid');
    $query->leftJoin('field_data_field_project_type', 'pt', 'w.sid = pt.entity_id');
    $count = $query->fields('w', array('sid'))
    ->condition('w.uid', $uid, '=')
    ->condition('n.type', $node_types, 'IN')
    ->condition('w.is_draft', (int) $draft)
    ->condition('w.submitted', $timestamp, '>')
    // field_project_type cannot be 2 (project idea)
    // We can directly place in the values with the where.
    ->where('pt.field_project_type_value IS NULL OR pt.field_project_type_value != 2')
    ->where("pt.entity_type IS NULL OR pt.entity_type = 'webform_submission_entity'")
    ->execute()
    ->rowCount();
  }
  catch (Exception $e) {
    $count = NULL;
  }

  return $count;
}

/**
 * Determine if a user has submitted a grant update within
 *  the given span of time.
 */
function dosomething_roles_user_submitted_grant($uid, $timestamp) {
  // TODO: Verify that this is the grant update.
  $query = new EntityFieldQuery;
  try {
    $count = $query
      ->entityCondition('entity_type', 'node')
      ->propertyCondition('uid', $uid)
      ->propertyCondition('type', 'final_grant_update')
      ->propertyCondition('status', NODE_PUBLISHED)
      ->propertyCondition('created', $timestamp, '>')
      ->count()
      ->execute();
  }
  catch (Exception $e) {
    return NULL;
  }
  return $count;
}

/**
 * Get the anniversary of this user's member level.
 *  When a user increases their role, they get it for one year.
 */
function dosomething_roles_get_anniversary($uid) {
  $account = user_load($uid);
  $profile = profile2_load_by_user($account, 'main');
  if (is_object($profile)) {
    $date = field_get_items('profile2', $profile, 'field_user_anniversary');
    if (isset($date[0]['value'])) {
      return $date[0]['value'];
    }
  }
  return REQUEST_TIME;
}

/**
 * Set a new membership anniversary for a user.
 */
function dosomething_roles_set_anniversary($uid, $timestamp) {
  $account = user_load($uid);
  $profile = profile2_load_by_user($account, 'main');
  // Create a profile if it doesn't exist.
  if (!$profile) {
    $values = array(
      'type' => 'main',
      'user' => $account,
    );
    $create_function = function_exists('profile2_create') ? 'profile_create' : 'profile_create';
    $profile = profile_create($values);
    profile2_save($profile);
  }

  $profile->field_user_anniversary[LANGUAGE_NONE][0]['value'] = $timestamp;
  field_attach_update('profile2', $profile);
}

/**
 * Determine how close a user is from moving to the next level.
 */
function dosomething_roles_get_user_percentage($uid) {
  $account = user_load($uid);
  $current_role = dosomething_roles_get_current_role($uid);
  $timestamp = strtotime('-1 year');
  $percent = 0;
  switch ($current_role) {
    case 'varsity':
      $percent = 100;
      break;
    case 'active member':
      $count = dosomething_roles_get_action_update_count($uid, $timestamp);
      $percent = $count > 5 ? 100 : 20 * $count;
      break;
    case 'member':
      $percent = 50 * dosomething_roles_profile_ratio($uid);
      if (dosomething_roles_get_action_update_count($uid, $timestamp)) {
        // If the user has submitted an action update then they get 50%.
        $percent += 50;
      }
      else if (dosomething_roles_get_action_update_count($uid, $timestamp, TRUE)) {
        // If the user has submitted a draft of an action update then they get 25%.
        $percent += 25;
      }
      break;
  }
  return $percent;
}

/**
 * Figure out how much of a user's profile has
 *  been committed.
 */
function dosomething_roles_profile_ratio($uid) {
  $account = user_load($uid);
  $profile = profile2_load_by_user($account, 'main');
  $check_fields = array(
    'field_user_birthday',
    'field_user_first_name',
    'field_user_last_name',
    'field_user_hearabout',
    'field_user_official_rules',
    'field_user_preferred_cause',
    'field_user_why_do_you',
    'field_user_mobile',
  );
  $address_fields = array(
    'thoroughfare',
    'locality',
    'administrative_area',
    'postal_code',
  );
  $total = 0;
  $complete = 0;

  if (is_object($profile)) {
    foreach ($check_fields as $field_name) {
      if (isset($profile->{$field_name})) {
        $total++;
        if (count($profile->{$field_name})) {
          $complete++;
        }
      }
    }
    // The address is always there because there's automatically a country.
    // So, we check fields within the address individually.
    // It would be nice if we could use addressfield_field_is_empty.
    if (isset($profile->field_user_address[LANGUAGE_NONE][0])) {
      foreach ($address_fields as $field) {
        $total++;
        if (!empty($profile->field_user_address[LANGUAGE_NONE][0][$field])) {
          $complete++;
        }
      }
    }
  }
  if ($total) {
    return $complete / $total;
  }
  return 0;
}

/**
 * Implements hook_form_profile2_edit_TYPE_form_alter().
 */
function dosomething_roles_form_profile2_edit_main_form_alter(&$form, &$form_state) {
  // Disable access to anniversary field.  This could be done with
  // field permissions, but until we need more fine grained permissions
  // on other fields, let's not add more overhead to this site.
  if (isset($form['profile_main']['field_user_anniversary'])) {
    unset($form['profile_main']['field_user_anniversary']);
  }
}

/**
 * TODO: Comment this stuff.
 */
function dosomething_roles_get_users_by_anniversary($start_date, $end_date = NULL, $limit = 10) {
  if (is_null($end_date)) {
    $end_date = REQUEST_TIME;
  }
  $query = new EntityFieldQuery;
  try {
    $results = $query
      ->entityCondition('entity_type', 'profile2')
      ->propertyCondition('type', 'main', '=')
      ->fieldCondition('field_user_anniversary', 'value', array($start_date, $end_date), 'BETWEEN')
      ->fieldOrderBy('field_user_anniversary', 'value')
      ->propertyOrderBy('uid')
      ->range(0, $limit)
      ->execute();
    return $results;
  }
  catch (Exception $e) {
    return NULL;
  }
  return $count;
}

