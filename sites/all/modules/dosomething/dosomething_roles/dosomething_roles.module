<?php

/**
 * @file
 * Custom functionality to change roles of users depending on their activity.
 */

/**
 * Implements hook_cron().
 */
function dosomething_roles_cron() {
  // Update users roles who have not been assigned to the new roles.
  // Note: this can be removed once all users have roles.
  $inactive_user = user_role_load_by_name('inactive user');
  $member = user_role_load_by_name('member');
  $active_member = user_role_load_by_name('active member');
  $rids = $inactive_user->rid . ', ' . $member->rid . ', ' . $active_member->rid;
  $result = db_query_range("SELECT u.uid, u.access FROM {users} u LEFT JOIN {users_roles} ur ON (ur.uid = u.uid AND ur.rid IN ($rids)) WHERE ur.uid IS NULL AND u.uid > 0 ORDER BY u.access ASC", 0, 100);
  foreach ($result as $data) {
    dosomething_roles_update_role($data->uid);
  }

  // Get users who have not logged in this past year for possible role regression.
  // TODO: Get users who have not done any action updates in 1 year, 9 months, 10 months, 11 months
  // After 1 year, we bump them down
  // We warn them at the other points.
  $last_update_inactive = variable_get('dosomething_roles_cron_inactive', 0);
  $result = db_query_range("SELECT u.uid, u.access FROM {users} u INNER JOIN {users_roles} ur ON (u.uid = ur.uid AND ur.rid IN (:active_member, :member)) WHERE access < UNIX_TIMESTAMP(DATE_SUB(CURRENT_TIMESTAMP(),interval 1 year)) AND access > :last_update_inactive ORDER BY u.access ASC", 0, 100, array(':active_member' => $active_member->rid, ':member' => $member->rid, ':last_update_inactive' => $last_update_inactive));
  foreach ($result as $data) {
     dosomething_roles_update_role($data->uid);
     variable_set('dosomething_roles_cron_inactive', $data->access);
  }
}

/**
 * Implements hook_mail().
 */
function dosomething_roles_mail($key, &$message, $params) {
  switch ($key) {
    case 'dosomething-roles-old-person-email':
      $params['full_name'] = dosomething_login_get_user_full_name($params['account']);
      $message['subject'] = t('You\'re membership has expired.');
      $message['body'][] = drupal_html_to_text(theme('dosomething_roles_old_person_email', $params));
      $message['headers']['Content-Type'] = 'text/html; charset=utf-8';
      break;
  }
}

/**
 * Implements hook_theme().
 */
function dosomething_roles_theme() {
  return array(
    'dosomething_roles_old_person_email' => array(
      'path' => drupal_get_path('module', 'dosomething_roles') . '/templates',
      'arguments' => array('full_name' => NULL),
      'template' => 'dosomething-roles-old-person-email',
    ),
  );
}

/**
 * Update a user's membership role.
 */
function dosomething_roles_update_role($uid) {
  if (!$uid || $uid == 1) {
    return;
  }
  global $language;
  $account = user_load($uid);

  // TODO: Maybe we should have another role to mark
  // non-staff users so we can check for that.
  $staff_roles = array(
    'administrator',
    'content loader',
    'developer',
    'grant reviewer',
    'grant alumni',
    'help desk',
    'moderator',
    'project_police',
  );
  // Make sure this user is not a staff member.
  if (count(array_intersect($staff_roles, $account->roles))) {
    return;
  }

  // TODO: It would be nice to do the hierarchy with the role weights.
  $rids = array();
  $roles = user_roles();
  $current_role_name = 'inactive user';
  $role_hierarchy = array(
    'varsity',
    'active member',
    'member',
    'inactive member',
    'old person',
  );
  foreach ($role_hierarchy as $weight => $role_name) {
    $rid = array_search($role_name, $roles);
    $rids[$role_name] = $rid;

    // Note: only one of these roles should be in the roles list.
    if (in_array($role_name, $account->roles)) {
      $current_role_name = $role_name;
    }
  }

  $new_role_name = dosomething_roles_get_member_role($uid);
  $anniversary = dosomething_roles_get_anniversary($uid);
  $new_role_weight = array_search($new_role_name, $role_hierarchy);
  $current_role_weight = array_search($current_role_name, $role_hierarchy);
  $new_anniversary = strtotime('+1 year');

  // If the role has increased, increase the role, and set new anniversary
  if ($new_role_weight < $current_role_weight) {
    dosomething_roles_set_anniversary($uid, $new_anniversary);
    $new_rid = $rids[$new_role_name];
  }
  // Else if it's past the anniverary set a new anniversary.
  else if (REQUEST_TIME >= $anniversary) {
    dosomething_roles_set_anniversary($uid, $new_anniversary);
    if ($new_role_weight > $current_role_weight) {
      // If the role level has decreased, then downgrade.
      // It can only ever downgrade by one.
      $role_name = $role_hierarchy[$current_role_weight + 1];
      $new_rid = $rids[$role_name];
    }
  }

  if ($new_role_name == 'old person' && $new_role_name != $current_role_name) {
    // Note: It may be better to user_save here.  If we decide to, then we need
    //  to add a flag to the account object (no_dosomething_role_update) to
    //  prevent an infinite loop.
    global $language;
    db_update('users')->fields(array('status' => 0))->condition('uid', $account->uid)->execute();
    $params = array('account' => $account);
    drupal_mail('dosomething_roles', 'dosomething-roles-old-person-email', $accopunt->mail, $language, $params);
  }

  if (isset($new_rid)) {
    db_delete('users_roles')->condition('rid', $rids, 'IN')->condition('uid', $uid, '=')->execute();
    db_insert('users_roles')->fields(array('uid' => $uid, 'rid' => $new_rid ))->execute();
  }
}

/**
 * Get a list of node types that are considered 'action updates'.
 */
function dosomething_roles_get_action_update_types() {
  return array(
    'campaign_report_back',
    'campaign_sign_up',
    'grant_application',
    'scholarship_application',
    'action_guide',
    'project_report',
  );
}

/**
 * Implements hook_node_insert().
 */
function dosomething_roles_node_insert($node) {
  global $user;
  if ($user->uid == $node->uid) {
    if ($node->type == 'final_grant_update') {
      dosomething_roles_update_role($node->uid);
    }
  }
}

/**
 * Implements hook_user_login().
 */
function dosomething_roles_user_login(&$edit, $account) {
  // Don't run this on the first login.
  if ($account->access) {
    dosomething_roles_update_role($account->uid);
  }
}

/**
 * Implements hook_user_update().
 */
function dosomething_roles_user_update(&$edit, $account, $category) {
  global $user;
  // To prevent infinite loop, add no_dosomething_role_update if running
  // user_save while updating a role.
  if ($user->uid == $account->uid && !isset($account->no_dosomething_role_update)) {
    dosomething_roles_update_role($account->uid);
  }
}

/**
 * Implements hook_webform_submission_insert().
 */
function dosomething_roles_webform_submission_insert($node, $submission) {
  global $user;
  if ($user->uid == $submission->uid) {
    if (in_array($node->type, dosomething_roles_get_action_update_types())) {
      dosomething_roles_update_role($submission->uid);
    }
  }
}

/**
 * Determine a user's role level without considering their 'Aniversary Date'
 *  when the role to actually change.
 *  old person - user over 25.
 *  inactive user - under 26, hasn't logged in in over a year.
 *  member - continue to be under 26.
 *  active member - one action update within year.
 *    TODO: They also must provide their school name and zipcode,
 *    but we're not sure where that's stored.
 *    TODO: If their action update is unpublished, then they should
 *    immediately fall to 'member'.
 *  varsity - 5 action updates or win grant and submit grant update.
 *    TODO: When the grant update is a year old, they should fall to
 *    'member' if they don't have any action updates.
 */
function dosomething_roles_get_member_role($uid) {
  $account = user_load($uid);
  $timestamp = strtotime('-1 year');
  $action_update_count = dosomething_roles_get_action_update_count($uid, $timestamp);
  $grant_update = dosomething_roles_user_submitted_grant($uid, $timestamp);

  if (module_exists('dosomething_login')) {
    if (dosomething_login_drupal_user_is_over_age($uid, 25)) {
      return 'old person';
    }
  }
  if ($action_update_count >= 5 || $grant_update) {
    $role_name = 'varsity';
  }
  else if ($action_update_count >= 1) {
    $role_name = 'active member';
  }
  else if ($account->login >= strtotime('-1 year')) {
    $role_name = 'member';
  }
  else {
    $role_name = 'inactive member';
  }
  return $role_name;
}

/**
 * This will get the number of action updates since the given time.
 *
 * @param $uid
 * @param $timestamp
 * @return mixed
 *  Returns int or NULL if unsuccessful.
 */
function dosomething_roles_get_action_update_count($uid, $timestamp) {
  // TODO: If the status is 'Idea' it doesn't count.
  // What is this status?
  $node_types = dosomething_roles_get_action_update_types();
  try {
    $query = db_select('webform_submissions', 'w');
    $query->innerJoin('node', 'n', 'w.nid = n.nid');
    $count = $query->fields('w', array('sid'))
    ->condition('w.uid', $uid, '=')
    ->condition('n.type', $node_types, 'IN')
    ->condition('w.is_draft', 0)
    ->condition('w.submitted', $timestamp, '>')
    ->execute()
    ->rowCount();
  }
  catch (Exception $e) {
    $count = NULL;
  }
  return $count;
}

/**
 * Determine if a user has submitted a grant update within
 *  the given span of time.
 */
function dosomething_roles_user_submitted_grant($uid, $timestamp) {
  // TODO: Verify that this is the grant update.
  $query = new EntityFieldQuery;
  try {
    $count = $query
      ->entityCondition('entity_type', 'node')
      ->propertyCondition('uid', $uid)
      ->propertyCondition('type', 'final_grant_update')
      ->propertyCondition('status', NODE_PUBLISHED)
      ->propertyCondition('created', $timestamp, '>')
      ->count()
      ->execute();
  }
  catch (Exception $e) {
    return NULL;
  }
  return $count;
}

/**
 * Get the anniversary of this user's member level.
 *  When a user increases their role, they get it for one year.
 */
function dosomething_roles_get_anniversary($uid) {
  $account = user_load($uid);
  $profile = profile2_load_by_user($account, 'main');
  if (is_object($profile)) {
    $date = field_get_items('profile2', $profile, 'field_user_anniversary');
    if (isset($date[0]['value'])) {
      return $date[0]['value'];
    }
  }
  return REQUEST_TIME;
}

/**
 * Set a new membership anniversary for a user.
 */
function dosomething_roles_set_anniversary($uid, $timestamp) {
  $account = user_load($uid);
  $profile = profile2_load_by_user($account, 'main');
  // Create a profile if it doesn't exist.
  if (!$profile) {
    $values = array(
      'type' => 'main',
      'user' => $account,
    );
    $create_function = function_exists('profile2_create') ? 'profile_create' : 'profile_create';
    $profile = profile_create($values);
    profile2_save($profile);
  }

  $profile->field_user_anniversary[LANGUAGE_NONE][0]['value'] = $timestamp;
  field_attach_update('profile2', $profile);
}

/**
 * Implements hook_form_profile2_edit_TYPE_form_alter().
 */
function dosomething_roles_form_profile2_edit_main_form_alter(&$form, &$form_state) {
  // Disalbe access to anniversary field.  This could be done with
  // field permissions, but until we need more fine grained permissions
  // on other fields, let's not add more overhead to this site.
  if (isset($form['profile_main']['field_user_anniversary'])) {
    unset($form['profile_main']['field_user_anniversary']);
  }
}

